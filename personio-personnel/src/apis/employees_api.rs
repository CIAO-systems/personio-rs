/*
 * Personnel Data
 *
 * API for reading and writing personnel data including data about attendances, absences, documents, etc
 *
 * The version of the OpenAPI document: 1.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`company_employees_attributes_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CompanyEmployeesAttributesGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`company_employees_custom_attributes_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CompanyEmployeesCustomAttributesGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`company_employees_employee_id_absences_balance_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CompanyEmployeesEmployeeIdAbsencesBalanceGetError {
    Status404(models::Employee404ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`company_employees_employee_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CompanyEmployeesEmployeeIdGetError {
    Status404(models::Employee404ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`company_employees_employee_id_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CompanyEmployeesEmployeeIdPatchError {
    Status422(models::EmployeeUpdateErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`company_employees_employee_id_profile_picture_width_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CompanyEmployeesEmployeeIdProfilePictureWidthGetError {
    Status404(models::Employee404ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`company_employees_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CompanyEmployeesGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`company_employees_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CompanyEmployeesPostError {
    Status422(models::EmployeeCreationErrorResponse),
    UnknownValue(serde_json::Value),
}


/// Lists all the allowed atrributes per API credentials including custom (dynamic) attributes.
pub async fn company_employees_attributes_get(configuration: &configuration::Configuration, x_personio_partner_id: Option<&str>, x_personio_app_id: Option<&str>) -> Result<(), Error<CompanyEmployeesAttributesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_x_personio_partner_id = x_personio_partner_id;
    let p_x_personio_app_id = x_personio_app_id;

    let uri_str = format!("{}/company/employees/attributes", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_personio_partner_id {
        req_builder = req_builder.header("X-Personio-Partner-ID", param_value.to_string());
    }
    if let Some(param_value) = p_x_personio_app_id {
        req_builder = req_builder.header("X-Personio-App-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CompanyEmployeesAttributesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// This endpoint is an alias for `/company/employees/attributes`.
pub async fn company_employees_custom_attributes_get(configuration: &configuration::Configuration, x_personio_partner_id: Option<&str>, x_personio_app_id: Option<&str>) -> Result<(), Error<CompanyEmployeesCustomAttributesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_x_personio_partner_id = x_personio_partner_id;
    let p_x_personio_app_id = x_personio_app_id;

    let uri_str = format!("{}/company/employees/custom-attributes", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_personio_partner_id {
        req_builder = req_builder.header("X-Personio-Partner-ID", param_value.to_string());
    }
    if let Some(param_value) = p_x_personio_app_id {
        req_builder = req_builder.header("X-Personio-App-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CompanyEmployeesCustomAttributesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve the absence balance for a specific employee
pub async fn company_employees_employee_id_absences_balance_get(configuration: &configuration::Configuration, employee_id: i32, x_personio_partner_id: Option<&str>, x_personio_app_id: Option<&str>) -> Result<models::EmployeeAbsenceBalance, Error<CompanyEmployeesEmployeeIdAbsencesBalanceGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_employee_id = employee_id;
    let p_x_personio_partner_id = x_personio_partner_id;
    let p_x_personio_app_id = x_personio_app_id;

    let uri_str = format!("{}/company/employees/{employee_id}/absences/balance", configuration.base_path, employee_id=p_employee_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_personio_partner_id {
        req_builder = req_builder.header("X-Personio-Partner-ID", param_value.to_string());
    }
    if let Some(param_value) = p_x_personio_app_id {
        req_builder = req_builder.header("X-Personio-App-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EmployeeAbsenceBalance`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EmployeeAbsenceBalance`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CompanyEmployeesEmployeeIdAbsencesBalanceGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get Employee by ID
pub async fn company_employees_employee_id_get(configuration: &configuration::Configuration, employee_id: i32, x_personio_partner_id: Option<&str>, x_personio_app_id: Option<&str>) -> Result<models::EmployeeResponse, Error<CompanyEmployeesEmployeeIdGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_employee_id = employee_id;
    let p_x_personio_partner_id = x_personio_partner_id;
    let p_x_personio_app_id = x_personio_app_id;

    let uri_str = format!("{}/company/employees/{employee_id}", configuration.base_path, employee_id=p_employee_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_personio_partner_id {
        req_builder = req_builder.header("X-Personio-Partner-ID", param_value.to_string());
    }
    if let Some(param_value) = p_x_personio_app_id {
        req_builder = req_builder.header("X-Personio-App-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EmployeeResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EmployeeResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CompanyEmployeesEmployeeIdGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates an existing employee. Note: Only the fields that are listed in the body example are updatable. Attributes that are not part of the sample request body but are present inside the request are ignored. It's not possible to update the Email field. 
pub async fn company_employees_employee_id_patch(configuration: &configuration::Configuration, employee_id: i32, x_personio_partner_id: Option<&str>, x_personio_app_id: Option<&str>, company_employees_employee_id_patch_request: Option<models::CompanyEmployeesEmployeeIdPatchRequest>) -> Result<models::EmployeeUpdatedResponse, Error<CompanyEmployeesEmployeeIdPatchError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_employee_id = employee_id;
    let p_x_personio_partner_id = x_personio_partner_id;
    let p_x_personio_app_id = x_personio_app_id;
    let p_company_employees_employee_id_patch_request = company_employees_employee_id_patch_request;

    let uri_str = format!("{}/company/employees/{employee_id}", configuration.base_path, employee_id=p_employee_id);
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_personio_partner_id {
        req_builder = req_builder.header("X-Personio-Partner-ID", param_value.to_string());
    }
    if let Some(param_value) = p_x_personio_app_id {
        req_builder = req_builder.header("X-Personio-App-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_company_employees_employee_id_patch_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EmployeeUpdatedResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EmployeeUpdatedResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CompanyEmployeesEmployeeIdPatchError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Show employee's profile picture. If profile picture is missing, the 404 error will be thrown. The `Profile Picture` attribute has to be whitelisted.
pub async fn company_employees_employee_id_profile_picture_width_get(configuration: &configuration::Configuration, employee_id: i32, width: i32, x_personio_partner_id: Option<&str>, x_personio_app_id: Option<&str>) -> Result<reqwest::Response, Error<CompanyEmployeesEmployeeIdProfilePictureWidthGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_employee_id = employee_id;
    let p_width = width;
    let p_x_personio_partner_id = x_personio_partner_id;
    let p_x_personio_app_id = x_personio_app_id;

    let uri_str = format!("{}/company/employees/{employee_id}/profile-picture/{width}", configuration.base_path, employee_id=p_employee_id, width=p_width);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_personio_partner_id {
        req_builder = req_builder.header("X-Personio-Partner-ID", param_value.to_string());
    }
    if let Some(param_value) = p_x_personio_app_id {
        req_builder = req_builder.header("X-Personio-App-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(resp)
    } else {
        let content = resp.text().await?;
        let entity: Option<CompanyEmployeesEmployeeIdProfilePictureWidthGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// List Company Employees
pub async fn company_employees_get(configuration: &configuration::Configuration, x_personio_partner_id: Option<&str>, x_personio_app_id: Option<&str>, limit: Option<i32>, offset: Option<i32>, email: Option<&str>, attributes_left_square_bracket_right_square_bracket: Option<Vec<String>>, updated_since: Option<&str>) -> Result<models::EmployeesResponse, Error<CompanyEmployeesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_x_personio_partner_id = x_personio_partner_id;
    let p_x_personio_app_id = x_personio_app_id;
    let p_limit = limit;
    let p_offset = offset;
    let p_email = email;
    let p_attributes_left_square_bracket_right_square_bracket = attributes_left_square_bracket_right_square_bracket;
    let p_updated_since = updated_since;

    let uri_str = format!("{}/company/employees", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_email {
        req_builder = req_builder.query(&[("email", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_attributes_left_square_bracket_right_square_bracket {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("attributes[]".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("attributes[]", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_updated_since {
        req_builder = req_builder.query(&[("updated_since", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_personio_partner_id {
        req_builder = req_builder.header("X-Personio-Partner-ID", param_value.to_string());
    }
    if let Some(param_value) = p_x_personio_app_id {
        req_builder = req_builder.header("X-Personio-App-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EmployeesResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EmployeesResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CompanyEmployeesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a new employee. If the employee's status is not provided, it will be set based on the `hire_date` value - if it is in the past, status will be `active`, otherwise `onboarding`. This endpoint responds with the `id` of the created employee in case of success. 
pub async fn company_employees_post(configuration: &configuration::Configuration, x_personio_partner_id: Option<&str>, x_personio_app_id: Option<&str>, company_employees_post_request: Option<models::CompanyEmployeesPostRequest>) -> Result<models::EmployeeCreatedResponse, Error<CompanyEmployeesPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_x_personio_partner_id = x_personio_partner_id;
    let p_x_personio_app_id = x_personio_app_id;
    let p_company_employees_post_request = company_employees_post_request;

    let uri_str = format!("{}/company/employees", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_personio_partner_id {
        req_builder = req_builder.header("X-Personio-Partner-ID", param_value.to_string());
    }
    if let Some(param_value) = p_x_personio_app_id {
        req_builder = req_builder.header("X-Personio-App-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_company_employees_post_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EmployeeCreatedResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EmployeeCreatedResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CompanyEmployeesPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

