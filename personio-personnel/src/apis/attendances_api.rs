/*
 * Personnel Data
 *
 * API for reading and writing personnel data including data about attendances, absences, documents, etc
 *
 * The version of the OpenAPI document: 1.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`company_attendances_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CompanyAttendancesGetError {
    Status401(models::ErrorResponse),
    Status403(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`company_attendances_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CompanyAttendancesIdDeleteError {
    Status400(models::AttendanceDelete400ErrorResponse),
    Status401(models::ErrorResponse),
    Status403(models::ErrorResponse),
    Status404(models::Attendance404ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`company_attendances_id_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CompanyAttendancesIdPatchError {
    Status400(models::AttendanceCreateUpdate400ErrorResponse),
    Status401(models::ErrorResponse),
    Status403(models::ErrorResponse),
    Status404(models::Attendance404ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`company_attendances_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CompanyAttendancesPostError {
    Status401(models::ErrorResponse),
    Status403(models::ErrorResponse),
    Status400(models::AttendanceCreateUpdate400ErrorResponse),
    UnknownValue(serde_json::Value),
}


/// Fetch attendance data for the company employees. The result can be `paginated` and `filtered` by period, the date and/or time they were updated, and/or specific employee/employees. The result contains a list of attendances.
pub async fn company_attendances_get(configuration: &configuration::Configuration, start_date: String, end_date: String, x_personio_partner_id: Option<&str>, x_personio_app_id: Option<&str>, updated_from: Option<&str>, updated_to: Option<&str>, include_pending: Option<bool>, employees_left_square_bracket_right_square_bracket: Option<Vec<i32>>, limit: Option<i32>, offset: Option<i32>) -> Result<models::AttendancePeriodsResponse, Error<CompanyAttendancesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_start_date = start_date;
    let p_end_date = end_date;
    let p_x_personio_partner_id = x_personio_partner_id;
    let p_x_personio_app_id = x_personio_app_id;
    let p_updated_from = updated_from;
    let p_updated_to = updated_to;
    let p_include_pending = include_pending;
    let p_employees_left_square_bracket_right_square_bracket = employees_left_square_bracket_right_square_bracket;
    let p_limit = limit;
    let p_offset = offset;

    let uri_str = format!("{}/company/attendances", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("start_date", &p_start_date.to_string())]);
    req_builder = req_builder.query(&[("end_date", &p_end_date.to_string())]);
    if let Some(ref param_value) = p_updated_from {
        req_builder = req_builder.query(&[("updated_from", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_updated_to {
        req_builder = req_builder.query(&[("updated_to", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_pending {
        req_builder = req_builder.query(&[("includePending", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_employees_left_square_bracket_right_square_bracket {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("employees[]".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("employees[]", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_personio_partner_id {
        req_builder = req_builder.header("X-Personio-Partner-ID", param_value.to_string());
    }
    if let Some(param_value) = p_x_personio_app_id {
        req_builder = req_builder.header("X-Personio-App-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AttendancePeriodsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AttendancePeriodsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CompanyAttendancesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// This endpoint is responsible for deleting attendance data for the company employees.
pub async fn company_attendances_id_delete(configuration: &configuration::Configuration, id: i32, x_personio_partner_id: Option<&str>, x_personio_app_id: Option<&str>, skip_approval: Option<bool>) -> Result<models::DeletedAttendanceResponse, Error<CompanyAttendancesIdDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_x_personio_partner_id = x_personio_partner_id;
    let p_x_personio_app_id = x_personio_app_id;
    let p_skip_approval = skip_approval;

    let uri_str = format!("{}/company/attendances/{id}", configuration.base_path, id=p_id);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = p_skip_approval {
        req_builder = req_builder.query(&[("skip_approval", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_personio_partner_id {
        req_builder = req_builder.header("X-Personio-Partner-ID", param_value.to_string());
    }
    if let Some(param_value) = p_x_personio_app_id {
        req_builder = req_builder.header("X-Personio-App-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DeletedAttendanceResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DeletedAttendanceResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CompanyAttendancesIdDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// This endpoint is responsible for updating attendance data for the company employees. Attributes are not required and if not specified, the current value will be used. It is not possible to change the employee id.
pub async fn company_attendances_id_patch(configuration: &configuration::Configuration, id: i32, attendance_update_request: models::AttendanceUpdateRequest, x_personio_partner_id: Option<&str>, x_personio_app_id: Option<&str>) -> Result<models::UpdatedAttendanceResponse, Error<CompanyAttendancesIdPatchError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_attendance_update_request = attendance_update_request;
    let p_x_personio_partner_id = x_personio_partner_id;
    let p_x_personio_app_id = x_personio_app_id;

    let uri_str = format!("{}/company/attendances/{id}", configuration.base_path, id=p_id);
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_personio_partner_id {
        req_builder = req_builder.header("X-Personio-Partner-ID", param_value.to_string());
    }
    if let Some(param_value) = p_x_personio_app_id {
        req_builder = req_builder.header("X-Personio-App-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_attendance_update_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UpdatedAttendanceResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UpdatedAttendanceResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CompanyAttendancesIdPatchError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// This endpoint is responsible for adding attendance data for the company employees. It is possible to add attendances for one or many employees at the same time. The payload sent on the request should be a list of attendance periods, in the form of an array containing attendance period objects.
pub async fn company_attendances_post(configuration: &configuration::Configuration, attendance_create_request: models::AttendanceCreateRequest, x_personio_partner_id: Option<&str>, x_personio_app_id: Option<&str>) -> Result<models::NewAttendancePeriodResponse, Error<CompanyAttendancesPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_attendance_create_request = attendance_create_request;
    let p_x_personio_partner_id = x_personio_partner_id;
    let p_x_personio_app_id = x_personio_app_id;

    let uri_str = format!("{}/company/attendances", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_personio_partner_id {
        req_builder = req_builder.header("X-Personio-Partner-ID", param_value.to_string());
    }
    if let Some(param_value) = p_x_personio_app_id {
        req_builder = req_builder.header("X-Personio-App-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_attendance_create_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::NewAttendancePeriodResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::NewAttendancePeriodResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CompanyAttendancesPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

