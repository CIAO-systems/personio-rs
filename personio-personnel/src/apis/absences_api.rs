/*
 * Personnel Data
 *
 * API for reading and writing personnel data including data about attendances, absences, documents, etc
 *
 * The version of the OpenAPI document: 1.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`company_absence_periods_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CompanyAbsencePeriodsGetError {
    Status400(models::ErrorResponse),
    Status404(models::CompanyAbsencePeriodsGet404Response),
    Status500(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`company_absence_periods_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CompanyAbsencePeriodsIdDeleteError {
    Status404(models::ErrorAbsenceResponse),
    Status400(models::ErrorAbsenceResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`company_absence_periods_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CompanyAbsencePeriodsPostError {
    Status400(models::ErrorInsertingAbsenceResponse),
    Status404(models::ErrorResponse),
    Status422(models::ErrorCreateAbsenceResponse),
    Status500(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`company_time_off_types_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CompanyTimeOffTypesGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`company_time_offs_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CompanyTimeOffsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`company_time_offs_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CompanyTimeOffsIdDeleteError {
    Status400(models::ErrorAbsenceResponse),
    Status404(models::ErrorAbsenceResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`company_time_offs_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CompanyTimeOffsIdGetError {
    Status404(models::ErrorAbsenceResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`company_time_offs_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CompanyTimeOffsPostError {
    Status400(models::ErrorInsertingAbsenceResponse),
    Status404(models::ErrorResponse),
    Status422(models::ErrorCreateAbsenceResponse),
    UnknownValue(serde_json::Value),
}


/// Fetches absence periods for absences with **time unit** set to **hours**. The result can be `paginated` and `filtered` by period and/or specific employee/employees. The result contains a list of hourly absence periods.
pub async fn company_absence_periods_get(configuration: &configuration::Configuration, x_personio_partner_id: Option<&str>, x_personio_app_id: Option<&str>, start_date: Option<String>, end_date: Option<String>, updated_from: Option<String>, updated_to: Option<String>, employees_left_square_bracket_right_square_bracket: Option<Vec<i32>>, absence_types_left_square_bracket_right_square_bracket: Option<Vec<String>>, absence_periods_left_square_bracket_right_square_bracket: Option<Vec<String>>, limit: Option<i32>, offset: Option<i32>) -> Result<models::HourlyAbsencePeriodsResponse, Error<CompanyAbsencePeriodsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_x_personio_partner_id = x_personio_partner_id;
    let p_x_personio_app_id = x_personio_app_id;
    let p_start_date = start_date;
    let p_end_date = end_date;
    let p_updated_from = updated_from;
    let p_updated_to = updated_to;
    let p_employees_left_square_bracket_right_square_bracket = employees_left_square_bracket_right_square_bracket;
    let p_absence_types_left_square_bracket_right_square_bracket = absence_types_left_square_bracket_right_square_bracket;
    let p_absence_periods_left_square_bracket_right_square_bracket = absence_periods_left_square_bracket_right_square_bracket;
    let p_limit = limit;
    let p_offset = offset;

    let uri_str = format!("{}/company/absence-periods", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_updated_from {
        req_builder = req_builder.query(&[("updated_from", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_updated_to {
        req_builder = req_builder.query(&[("updated_to", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_employees_left_square_bracket_right_square_bracket {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("employees[]".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("employees[]", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_absence_types_left_square_bracket_right_square_bracket {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("absence_types[]".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("absence_types[]", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_absence_periods_left_square_bracket_right_square_bracket {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("absence_periods[]".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("absence_periods[]", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_personio_partner_id {
        req_builder = req_builder.header("X-Personio-Partner-ID", param_value.to_string());
    }
    if let Some(param_value) = p_x_personio_app_id {
        req_builder = req_builder.header("X-Personio-App-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::HourlyAbsencePeriodsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::HourlyAbsencePeriodsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CompanyAbsencePeriodsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Deletes absence period data for absence types with **time unit** set to **hours**.
pub async fn company_absence_periods_id_delete(configuration: &configuration::Configuration, id: &str, x_personio_partner_id: Option<&str>, x_personio_app_id: Option<&str>) -> Result<models::DeletedAbsenceResponse, Error<CompanyAbsencePeriodsIdDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_x_personio_partner_id = x_personio_partner_id;
    let p_x_personio_app_id = x_personio_app_id;

    let uri_str = format!("{}/company/absence-periods/{id}", configuration.base_path, id=crate::apis::urlencode(p_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_personio_partner_id {
        req_builder = req_builder.header("X-Personio-Partner-ID", param_value.to_string());
    }
    if let Some(param_value) = p_x_personio_app_id {
        req_builder = req_builder.header("X-Personio-App-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DeletedAbsenceResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DeletedAbsenceResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CompanyAbsencePeriodsIdDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Adds absence data for absence types with **time unit** set to **hours**. Note that creating periods for absence types with certificate requirement enabled is not supported!
pub async fn company_absence_periods_post(configuration: &configuration::Configuration, employee_id: i32, time_off_type_id: i32, start_date: String, end_date: String, x_personio_partner_id: Option<&str>, x_personio_app_id: Option<&str>, start_time: Option<String>, end_time: Option<String>, half_day_start: Option<bool>, half_day_end: Option<bool>, comment: Option<&str>, skip_approval: Option<bool>) -> Result<models::CompanyAbsencePeriodsPost201Response, Error<CompanyAbsencePeriodsPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_employee_id = employee_id;
    let p_time_off_type_id = time_off_type_id;
    let p_start_date = start_date;
    let p_end_date = end_date;
    let p_x_personio_partner_id = x_personio_partner_id;
    let p_x_personio_app_id = x_personio_app_id;
    let p_start_time = start_time;
    let p_end_time = end_time;
    let p_half_day_start = half_day_start;
    let p_half_day_end = half_day_end;
    let p_comment = comment;
    let p_skip_approval = skip_approval;

    let uri_str = format!("{}/company/absence-periods", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_personio_partner_id {
        req_builder = req_builder.header("X-Personio-Partner-ID", param_value.to_string());
    }
    if let Some(param_value) = p_x_personio_app_id {
        req_builder = req_builder.header("X-Personio-App-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    let mut multipart_form_params = std::collections::HashMap::new();
    multipart_form_params.insert("employee_id", p_employee_id.to_string());
    multipart_form_params.insert("time_off_type_id", p_time_off_type_id.to_string());
    multipart_form_params.insert("start_date", p_start_date.to_string());
    multipart_form_params.insert("end_date", p_end_date.to_string());
    if let Some(param_value) = p_start_time {
        multipart_form_params.insert("start_time", param_value.to_string());
    }
    if let Some(param_value) = p_end_time {
        multipart_form_params.insert("end_time", param_value.to_string());
    }
    if let Some(param_value) = p_half_day_start {
        multipart_form_params.insert("half_day_start", param_value.to_string());
    }
    if let Some(param_value) = p_half_day_end {
        multipart_form_params.insert("half_day_end", param_value.to_string());
    }
    if let Some(param_value) = p_comment {
        multipart_form_params.insert("comment", param_value.to_string());
    }
    if let Some(param_value) = p_skip_approval {
        multipart_form_params.insert("skip_approval", param_value.to_string());
    }
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CompanyAbsencePeriodsPost201Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CompanyAbsencePeriodsPost201Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CompanyAbsencePeriodsPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Provides a list of absence types for absences **time unit** set to either **days** or **hours**. For example 'Paid vacation', 'Parental leave' or 'Home office'.
pub async fn company_time_off_types_get(configuration: &configuration::Configuration, x_personio_partner_id: Option<&str>, x_personio_app_id: Option<&str>, limit: Option<i32>, offset: Option<i32>) -> Result<models::CompanyTimeOffTypesGet200Response, Error<CompanyTimeOffTypesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_x_personio_partner_id = x_personio_partner_id;
    let p_x_personio_app_id = x_personio_app_id;
    let p_limit = limit;
    let p_offset = offset;

    let uri_str = format!("{}/company/time-off-types", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_personio_partner_id {
        req_builder = req_builder.header("X-Personio-Partner-ID", param_value.to_string());
    }
    if let Some(param_value) = p_x_personio_app_id {
        req_builder = req_builder.header("X-Personio-App-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CompanyTimeOffTypesGet200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CompanyTimeOffTypesGet200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CompanyTimeOffTypesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Fetches absence periods for absences with **time unit** set to **days**. The result can be `paginated` and `filtered` by period and/or specific employee/employees. The result contains a list of absence periods.
pub async fn company_time_offs_get(configuration: &configuration::Configuration, x_personio_partner_id: Option<&str>, x_personio_app_id: Option<&str>, start_date: Option<String>, end_date: Option<String>, updated_from: Option<String>, updated_to: Option<String>, employees_left_square_bracket_right_square_bracket: Option<Vec<i32>>, limit: Option<i32>, offset: Option<i32>) -> Result<models::AbsencePeriodsResponse, Error<CompanyTimeOffsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_x_personio_partner_id = x_personio_partner_id;
    let p_x_personio_app_id = x_personio_app_id;
    let p_start_date = start_date;
    let p_end_date = end_date;
    let p_updated_from = updated_from;
    let p_updated_to = updated_to;
    let p_employees_left_square_bracket_right_square_bracket = employees_left_square_bracket_right_square_bracket;
    let p_limit = limit;
    let p_offset = offset;

    let uri_str = format!("{}/company/time-offs", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_updated_from {
        req_builder = req_builder.query(&[("updated_from", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_updated_to {
        req_builder = req_builder.query(&[("updated_to", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_employees_left_square_bracket_right_square_bracket {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("employees[]".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("employees[]", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_personio_partner_id {
        req_builder = req_builder.header("X-Personio-Partner-ID", param_value.to_string());
    }
    if let Some(param_value) = p_x_personio_app_id {
        req_builder = req_builder.header("X-Personio-App-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AbsencePeriodsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AbsencePeriodsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CompanyTimeOffsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Deletes absence period data for absence types with **time unit** set to **days**.
pub async fn company_time_offs_id_delete(configuration: &configuration::Configuration, id: i32, x_personio_partner_id: Option<&str>, x_personio_app_id: Option<&str>) -> Result<models::DeletedAbsenceResponse, Error<CompanyTimeOffsIdDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_x_personio_partner_id = x_personio_partner_id;
    let p_x_personio_app_id = x_personio_app_id;

    let uri_str = format!("{}/company/time-offs/{id}", configuration.base_path, id=p_id);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_personio_partner_id {
        req_builder = req_builder.header("X-Personio-Partner-ID", param_value.to_string());
    }
    if let Some(param_value) = p_x_personio_app_id {
        req_builder = req_builder.header("X-Personio-App-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DeletedAbsenceResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DeletedAbsenceResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CompanyTimeOffsIdDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets an absence period for absences with **time unit** set to **days**.
pub async fn company_time_offs_id_get(configuration: &configuration::Configuration, id: i32, x_personio_partner_id: Option<&str>, x_personio_app_id: Option<&str>) -> Result<models::AbsencePeriodResponse, Error<CompanyTimeOffsIdGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_x_personio_partner_id = x_personio_partner_id;
    let p_x_personio_app_id = x_personio_app_id;

    let uri_str = format!("{}/company/time-offs/{id}", configuration.base_path, id=p_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_personio_partner_id {
        req_builder = req_builder.header("X-Personio-Partner-ID", param_value.to_string());
    }
    if let Some(param_value) = p_x_personio_app_id {
        req_builder = req_builder.header("X-Personio-App-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AbsencePeriodResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AbsencePeriodResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CompanyTimeOffsIdGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Adds absence data for absence types with **time unit** set to **days**.
pub async fn company_time_offs_post(configuration: &configuration::Configuration, employee_id: i32, time_off_type_id: i32, start_date: String, end_date: String, half_day_start: bool, half_day_end: bool, x_personio_partner_id: Option<&str>, x_personio_app_id: Option<&str>, comment: Option<&str>, skip_approval: Option<bool>) -> Result<models::CompanyTimeOffsPost200Response, Error<CompanyTimeOffsPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_employee_id = employee_id;
    let p_time_off_type_id = time_off_type_id;
    let p_start_date = start_date;
    let p_end_date = end_date;
    let p_half_day_start = half_day_start;
    let p_half_day_end = half_day_end;
    let p_x_personio_partner_id = x_personio_partner_id;
    let p_x_personio_app_id = x_personio_app_id;
    let p_comment = comment;
    let p_skip_approval = skip_approval;

    let uri_str = format!("{}/company/time-offs", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_personio_partner_id {
        req_builder = req_builder.header("X-Personio-Partner-ID", param_value.to_string());
    }
    if let Some(param_value) = p_x_personio_app_id {
        req_builder = req_builder.header("X-Personio-App-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    let mut multipart_form_params = std::collections::HashMap::new();
    multipart_form_params.insert("employee_id", p_employee_id.to_string());
    multipart_form_params.insert("time_off_type_id", p_time_off_type_id.to_string());
    multipart_form_params.insert("start_date", p_start_date.to_string());
    multipart_form_params.insert("end_date", p_end_date.to_string());
    multipart_form_params.insert("half_day_start", p_half_day_start.to_string());
    multipart_form_params.insert("half_day_end", p_half_day_end.to_string());
    if let Some(param_value) = p_comment {
        multipart_form_params.insert("comment", param_value.to_string());
    }
    if let Some(param_value) = p_skip_approval {
        multipart_form_params.insert("skip_approval", param_value.to_string());
    }
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CompanyTimeOffsPost200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CompanyTimeOffsPost200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CompanyTimeOffsPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

